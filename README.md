# Отчет по реализации реактивной библиотеки

## Обзор архитектуры

Реализованная реактивная библиотека представляет собой упрощенную версию RxJava, разработанную для поддержки принципов реактивного программирования с использованием паттерна «Наблюдатель». Основные компоненты включают:

- **Интерфейс Observer**: Определяет методы `onNext`, `onError` и `onComplete` для обработки событий потока.
- **Класс Observable**: Основной источник реактивного потока, поддерживающий подписку и операторы, такие как `map`, `filter`, `flatMap`, `subscribeOn` и `observeOn`.
- **Интерфейс Disposable**: Управляет жизненным циклом подписки, позволяя отменять подписку.
- **Интерфейс Scheduler**: Абстрагирует выполнение потоков с реализациями для различных моделей потоков (IO, Computation, Single).
- **ObservableOnSubscribe**: Обеспечивает создание пользовательских источников Observable.
- **ObservableSubscribeProxy**: Оборачивает наблюдателей для управления отменой и обеспечения потокобезопасности.

Архитектура следует паттерну «цепочка ответственности», где операторы создают новые объекты Observable, оборачивающие исходный, преобразуя или фильтруя данные по мере необходимости. Планировщики интегрируются с `ExecutorService` из Java для управления асинхронным выполнением.

## Планировщики: принципы работы и применение

Библиотека включает три реализации планировщиков, каждая из которых подходит для определенных сценариев использования:

1. **IOThreadScheduler**:
    - Использует `CachedThreadPool` для динамического выделения потоков.
    - Идеально подходит для задач, связанных с вводом-выводом (например, сетевые операции или работа с файлами), где задачи возникают спорадически и имеют разную длительность.
    - Потоки повторно используются или создаются по мере необходимости, оптимизируя использование ресурсов для непредсказуемых нагрузок.

2. **ComputationScheduler**:
    - Использует `FixedThreadPool` с количеством потоков, равным числу доступных процессоров.
    - Подходит для задач, интенсивно использующих процессор (например, обработка данных, вычисления), где постоянное выделение потоков выгодно.
    - Ограничивает количество потоков, чтобы предотвратить конкуренцию за ресурсы, обеспечивая эффективное параллельное выполнение.

3. **SingleThreadScheduler**:
    - Использует однопоточный `ExecutorService` для последовательного выполнения.
    - Идеально подходит для задач, требующих строгого порядка выполнения или обновления пользовательского интерфейса (например, в Swing или JavaFX).
    - Гарантирует, что все задачи выполняются в одном потоке, упрощая синхронизацию.

Метод `subscribeOn` планирует процесс подписки, а `observeOn` — последующие операции (например, `onNext`, `onError`, `onComplete`). Это обеспечивает гибкое управление местом выполнения вычислений, улучшая производительность и отзывчивость.

## Процесс тестирования

Тестирование проводилось с использованием JUnit 5, с написанием комплексных модульных тестов, охватывающих следующие аспекты:

- **Создание и подписка Observable**: Проверено, что Observable корректно выдает элементы и завершает работу.
- **Операторы**:
    - `map`: Проверено преобразование целых чисел в строки.
    - `filter`: Убедились, что только элементы, соответствующие условию, передаются дальше.
    - `flatMap`: Проверено преобразование каждого элемента в новый поток Observable.
- **Обработка ошибок**: Подтверждено, что ошибки передаются в `onError` и останавливают дальнейшую эмиссию.
- **Планировщики**: Проверено, что `subscribeOn` и `observeOn` выполняются в правильных потоках с использованием проверки имен потоков.
- **Disposable**: Убедились, что подписки можно отменить, останавливая дальнейшую эмиссию.

Для синхронизации асинхронных операций в тестах использовался `CountDownLatch`, что обеспечило надежные результаты в многопоточной среде. Тестовый набор обеспечивает высокий охват ключевых сценариев, с четкими утверждениями и минимальными зависимостями.

## Примеры использования

Ниже приведены примеры, демонстрирующие функциональность библиотеки:

1. **Базовый Observable с map и filter**:
```java
Observable<Integer> observable = Observable.create(emitter -> {
    emitter.onNext(1);
    emitter.onNext(2);
    emitter.onNext(3);
    emitter.onComplete();
});

observable.map(x -> "Значение: " + x)
    .filter(s -> s.contains("2"))
    .subscribe(new Observer<String>() {
        @Override
        public void onNext(String item) {
            System.out.println(item); // Выводит: Значение: 2
        }

        @Override
        public void onError(Throwable t) {
            t.printStackTrace();
        }

        @Override
        public void onComplete() {
            System.out.println("Завершено");
        }
    });
```

2. **Асинхронное выполнение с планировщиками**:
```java
Observable<Integer> observable = Observable.create(emitter -> {
    emitter.onNext(1);
    emitter.onComplete();
});

Scheduler ioScheduler = new IOThreadScheduler();
Scheduler computationScheduler = new ComputationScheduler();

observable.subscribeOn(ioScheduler)
    .observeOn(computationScheduler)
    .subscribe(new Observer<Integer>() {
        @Override
        public void onNext(Integer item) {
            System.out.println("Получено: " + item + " в потоке: " + Thread.currentThread().getName());
        }

        @Override
        public void onError(Throwable t) {
            t.printStackTrace();
        }

        @Override
        public void onComplete() {
            System.out.println("Завершено в потоке: " + Thread.currentThread().getName());
        }
    });
```

3. **FlatMap и Disposable**:
```java
Observable<Integer> observable = Observable.create(emitter -> {
    emitter.onNext(1);
    emitter.onNext(2);
    emitter.onComplete();
});

Disposable disposable = observable.flatMap(x -> Observable.create(emitter -> {
    emitter.onNext(x * 10);
    emitter.onComplete();
})).subscribe(new Observer<Integer>() {
    @Override
    public void onNext(Integer item) {
        System.out.println(item);
        if (item == 10) {
            disposable.dispose();
        }
    }

    @Override
    public void onError(Throwable t) {
        t.printStackTrace();
    }

    @Override
    public void onComplete() {
        System.out.println("Завершено");
    }
});
```

## Заключение

Реализованная реактивная библиотека обеспечивает надежную основу для реактивного программирования, с поддержкой асинхронного выполнения, преобразования данных и обработки ошибок. Модульная конструкция обеспечивает расширяемость, а тесты подтверждают работоспособность. Планировщики предоставляют гибкое управление потоками, что делает библиотеку полезной для большого количества задач — от простой обработки данных до сложных асинхронных процессов.